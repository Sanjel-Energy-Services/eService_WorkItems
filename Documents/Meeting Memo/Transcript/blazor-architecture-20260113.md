00:00:00 
那么在在Blazor里面呢去去去调这个啊输数据请求的时候去数据更新都都是通过这个这个来走。都通过data service来走。那么service呢它在这边它会。去调这个repository。那么就是刚才秋峰讲的，就即使是这种啊形式主义的。在data service里头也要走，是是是这个意思吧。嗯，他这这个这个是他。

00:00:59 
我觉得应该是返回的是就是要么参数要么返回值一定有一个model的。不是返回的是不这个地方处理的这个地方处理都是model。这地方处处理的都是model，然后你在service里面呢，就是你service里面你可以你可能说说你返回的是这个呃viewmodel。你返回的肯你你service里头。你你你向后面发起请求，你你可能完成了你的view model向和和model之之间的那个，这个转换。对。那么这个这个data service呢如果是data service的话。你。是。

00:01:56 
如果是你要想想复有有可能复用的话，因为这这这种是view，这不是view model，然后后面这后面实际上就是转换成model，往后传嘛。虽然它这里面只是一个id，但是实际上你就说你会往后传嘛。实际上这这个地方是是可以可以转可以转化成那个model的，就是做做一个那个view model到model mapping就可就可以变成model的，对不对？那另外另外一一种服务呢，就是一些业务逻辑的服务。就是我们那个宝红我们说的那个。

00:02:51 
呃，process这个东西。那process呢一定是从这个从service去去去调这个呃。process，因为process因为，这个service呢它是，啊，在viewmodel和model之间进行转换，但是process呢就完全是这个就是是在在model上去操作。是不是这意思啊宝红。宝红掉线了。嗯嗯，没没没，再，再想，再重头再再说一下。不是这个这个有有可能跟这个上位组合并吗？啊。不是，现在现在我我们讲的说你从这个前台，你你从这个reser里面。

00:03:50 
向后台去去发起请求的话，我们要把这个变这这层变薄嘛是吧。我们把这层变薄，这个reser这层它就只只负责处处处理这个处理接接接界面的渲染，界面的输输输数据那个处理界面上的数数据处理和界面的事件响应嘛对吧。然后呢，那么如果任有有任何超超过这个这个这这个界界面处理的这个呃这个范畴的，那么我们的他的他都会向向后面向service发发起请求嘛。你比如说你需要需要数据，你需要数据，那你你这这个地方就向向service去要嘛。嗯对。

00:04:42 
你像是这个地方就应该是你这个你说要叫要叫叫这个呃，the call she the blind section。那么这个地方你可能是一个call she service。嗯。或或者是你你你啊。不是call she的service是。不是house service。它这个功能对应的那个service。它功能对应service，然后呢？呃，到到那供应测是那个service里头，他再去向那个后面的这个呃repository去去发起请求嘛，对吧？嗯，那么这个东西这个东西很如果是这个看它这个参数，这个很明显它不应该像是在这个repository里面，他应该是在call sheet的的repository里面。

00:05:45 
或者是我们再再细一点，就是call she the blind section the repository里面。嗯，但是它不管是什么repository，就是说我们在service这这一层，这个这这个拿出去就是它会向service发起发起请求，service然后再再去向不同的那个repository去去调不同repository的界面的的那个里面的方法去把把这要拿的数据拿到。那么就是这就你比如把把这一部分放到一起呢，在service里边呢，那按秋风说啊，就是包括包括这一部分，实际上拿就是可以可以从service里直直直接拿直接拿到就是这整个方法搬搬到service里面去。然后这在在在这个地方呢，就就就直接向service发起请求。

00:06:45 
是这意思吧？嗯。那么这这这种就就属于那个我们讲那个就是他他对这个其实我们讲这个这个他他对数数据进行组合处处理啊对然后对他进行的那个呃拆拆解组装啊那实际上就这就是我们的process。对吧你这一波。嗯。

00:07:20 
所以如果说是呃我如果在service里面呢，我们最后返回的是那什么，那么我们去呃处理处理这这个逻辑呢，我们可以再分出来叫叫叫process，对不对？嗯嗯，那么那process就完全是依依赖于model的，嗯，就是只只是逻辑不那么数数据读取，还是还是去通过那个什么通过这个repository去去读。把需要数据读进来，然后呃这个process就只只进行这些这些组装组装什么的这些这些逻辑。那么以后如果是说这个东西要要要共共你要共享的话，要共用的话。我们就呃可以把这把这个共用的逻辑从service里从这process里头直接拿到那个s ci library process里面去。那么在这个在这service里头去调这个process的时候呢。

00:08:17 
我们就调的是library里那process就行了。嗯，为啥不能直接调？因为放到library里边之后它是，data。它放在这个里边它是model。它不能直接调。啊，不能直接调，那那就是说说需需要我们把把这个把这个通过那个repository里头。去拐一下。做做接口拐一下，是不是？对，是的。那我们现在是说做一个service还是做俩service？就是说他像他那个就是说你是以页面页面哦。

00:09:16 
以页面为准的service还是以这个呃是以这个实体为为准的service。嗯，页面的就是就以页面吧。就是你这个那那啊。我倾向于页面或者组件，就是这个就是这个reader文件。对。这这这样的话规范好定啊，就是你有几个页面或者组件，那你就。

00:09:47 
对应的就去找它对应的service。那不那我们刚才讲讲你要是那个就那那你就是相当于说你你有两两套service嘛。一个是页面service，一个数一个数据service嘛。就你说那个process是吗？不是，那你页页面那是process。你那个数据的就是就就我直接我就。我就是就我直接就要了load的data嘛。也不用是吧，就就是以就是每个都以因为因为现在是考虑有些有有些东西可能呃就是如果出现复用的话。如果出出现复用可以放到call里吗。什么的费用。

00:10:45 
就是他这个，就是。如果以以页面为单位的话，那那就是。每每一个每一个result后面都都会有一个，相应都有一个service是吗？啊。

00:11:16 
啊，也可能没有，因为他他他如果比较简单，他就直接。比较简单嘛。啊。但是我们该你要讲一致性，你那个你让AI去生生成的话，它那它的那那你就必须得有啊。生成的话可以自动生成。对啊。呃，所以我说最多一个嘛，就是这样对。哦对。就必须一个嘛，就是说我们现在就是一个原则，就是说你。你一个页面，我们在这个这个里面，那么它这个里面呢。你看我们现在说。它是是怎么做的，user，的页面在在哪儿，它是。就是这些form嘛，每个都是这一个一个form对吧。那么我们需要为为每一个form去去去做一个service是吗。

00:12:15 
对。那这个这。这这谁做的component和那啥有啥区别啊？这是我做的，这是我最那个。最早最早做的。没有form的时候加的。啊。然后我当时想着。其实在放在components我我感觉。是更合理的，不一定都是form。对，是的。嗯，那是就是其实就是一个它就是一个命名空间嘛，对吧？就是你你把那那我们就说你把这个东西都换到component里面，但是现在component有两种，一种是呃是form，就是你相当于是一个一个页面嘛，就是说一个操作操操作页面对吧？form就是一个操作页面嘛，对吧？

00:13:15 
嗯嗯。然后你先先那么如果他有这个，你比如这这这个东西什么thermal这这个时候我还不知道从来不知道这个是。这这是哪来的？那没用吧有用吗？谁谁写的这么是thermal thermal。拼还拼错了thermal mix，不，blind request from。

00:13:47 
谁做的不知道。谁加这么个玩意儿？那那那现在我们那就是说你每一个，component。那么就是说把它都变成component。那每一个component，下面。就会对应着一个service，是吧？

00:14:44 
这个秋风，我们是说这个每一个component下面都都每一个component都都会对应自己一个service，是是这意思吗？我觉得这样好规范。那我我我们目前先先就是这目前阶段就第一次重购我们先不管process值。那个save on。嗯，就是我们因为因为我们我们分不清哪个是process哪个是什么，我们先把它那个从呃就是你现在做的这个product号这个呢就是就直直接其他不要动，就就就只是product号对吧？你只是schedule product号，然后呢。

00:15:37 
把这个schedule product haul这个给给给它挪到component那里面去。然后呢，你这个对对应就是有个schedule product haul的service。嗯嗯，他叫什么？他叫haul blend。啊，叫haul blend service啊。

00:16:08 
就叫hub line service嘛然后在这个reason里面所有的像像像就是所有的需要需要去那个请求数据什么的这个。就这这里面的所所有的这这些需要向后去请请求数据什么的都是向。都是在service像service直直接调service。逻辑在service里面，然后从service里头就是就这这这种我们就说我就是说不不去做那什么不去做这个呃process啊。如果你你你有什么感觉了呢？去这个觉着怎么合理，你可以试着做一个一个。

00:17:06 
啊，一个process做个process，可能就是这这就不是每process，肯定就是可可可以公用的嘛，对吧？好像是现在已经做了，做了很多了，我应该是会放到process.因为因为我我后来就是做做的时候，我们放到process都已经放到process，你process在在在这个里面。对。哦。哦。哦可以，那可以，那那有了就就那什么，那就是那你现在就是说那个呃，从service里面去去可以去哦，需要什么一些呃方法，可以就是转化成model以后去处理完了，到process里面处理处理再再返回来对吧？对。啊，你这已经有process了啊。行。

00:18:06 
主要的是，定和大部分的，那其他的好像都是，没写多少的。啊。那那就是说，我我process去去做存存逻辑，然后那个这个呃service就就做这个所所有为那个呃user来。提供这个啊数据的方法，和那个。就主因为就主要就是提提供数据嘛对吧。

00:18:36 
嗯，去进行数据处处理的交互啊。嗯。下来响应我的这个响应前台的请求，这是service的这职能，service是啊。它是请求是输入的是不是一个viewmodel，然后啊输输出是个model。输输它它不是输出它是它它是向像下一层去调repository，或者是或者是是转化成model去去去调那个process对吧？嗯嗯，process的都都都是静态方法嘛。那么你process里头会不会调repository也会。process调调肯定要调，因为他要去那个数据嘛，还是要操作数据的啊，但是要调。

00:19:35 
你是你是用用的那个event handler那个方就是传去那个是吧？对因为他俩他俩之间没办法互相依赖。啊，对啊，你你就是用用那个那个依赖注入去去去做的嘛。就依赖注入嘛，你你那边指。还不太一样。还不太一样。其实其实应该是，其实要的效果其。

00:20:05 
就写法不一样，不是那个传传的那个event。你不是传你你你这这这种你不是你这些这里有那啥呀。嗯，全全在上边点的，上边有一个region，region上边有一个event handler，确确实。哦就哦就是用event handler去去那啥，然后触触发一个那啥嘛，这这个那个就代理的方式去去做的。

00:20:37 
嗯，然后他这个注册是在。注册是在那个，在那个，呃，repository。在repository里面啊。它那个common有一个。business process event。folder。它注册是在这里。

00:21:08 
然后还有什么。还有我做的那个什么的时候。其实我在back plan，back plan底下还有一个back plan的文件。你这个是。那你这不又循环循环依赖了吗？你这repository，这这不是。又依赖那什么了吗？又依赖process啊？这没依赖其实只是给它注册了。就是只是把方法给它绑上了。不是你方法给它绑上了，但是你你只要你你对这个类依依赖你就实际上你就是依依赖了那个。依赖了process。依赖了process吗？对对是的。

00:22:05 
就是你还是个循环依赖嘛。嗯，嗯，对。所以你这你这个这个应该是应该是到那什么里头就不应该是在在这个里面注册，因为你你因为你的process是。你的process是比那什么。

00:22:37 
你的process比那个什么靠前，比就repository靠前嘛。所以你你哪怕是是你你。啊。但是你repository你又依赖于processor嘛不是。嗯，对，我用他的那个啥了，用他的名字了。对啊，所以你你可能在Blazor里做，你在Blazor里做注注册都都比在这儿注注注册强啊。不不不，这个呢，因为我在process里边调，不是我我是在repository里边调process的嘛。你是在repository里调process？我刚才不刚才不是说刚才不是说我们在service里面调process嘛。service里边调process的话，你将来挪到三六library的话，要又得改一下。

00:23:43 
是啊，我们我们刚才说了嘛，如如果说我们要走走Sanjellibrary里面挪到Sanjellibrary里的话，我们需要到时候我们需要在那个repository里头去过去拐一下嘛。对啊。但是在在什么在这个嗯因为我们有些东西会有就是我只要不复用的东西我们都都会留在这个。这个process里面。你看是这样，就是说因为我们这个这process呢，实际上我们是不是啊你现在是现现那个是那什么是怎么分的那个。

00:24:48 
那你你现在就等于说你如果叫process的话，它要向从service里头还要向那个repository里里面去。因为我们刚才讲的是repository，我们就是我们最最repository的职责，就主要是和和那个三张data去打交道嘛。所以你的process相相当于是本是本地服务嘛。那个三加library里呢是相当于是那个那个公共服务嘛，你所有的公共服务是通过那个repository走的，所以你你调那个本地process你不应该进不应该进那个走那个repository啊，repository是那公共服务的接口啊。

00:25:51 
是不是这个概念？嗯。repository是是那什么是这个，repository是，啊。它应该是以是以实实体为单位的。嗯。但我不知道这bin bin information。他们是这个这个repository如果是呃打包的话。这个也没有没没没有那个清清晰的那个打包。他这边repository是怎是怎么分怎么的怎么分的包。

00:26:50 
你propos就是他这边就是平的，他这就是就是用那个就就就是以以实体为单位嘛。那在这边，那谁做做做的时候就又给建进都给建了folder，folder里头，就是这只是自己的。或者自己相关的。这个是product haul，product haul就是自己相关的。啊，这还做了一个MDM。Mdm他就是做那个就是属于那个master data.那么jobs tatus这这这个不应该是他怎么还只搞了一个这job status repository，我没有jobs tatus，没有job status table啊，他做了一个这他这这这个东西就是明明显应该是他是他这里有有一部分，就应该是在在service里面嘛。

00:27:47 
他去他去组这些model应该应该是在那个service里面嘛。就这这就是他这里做做这些东西实际上就是说事情应该在service里面去做的事情。service里面在这边里逻辑是提可以提到process里面的嘛对吧。那么我们的repository就应该是。以这个是以实体为单位的。他要以实体为单位的话，那就跟。那那直接那个sales。

00:28:44 
嗯，看360大service。没有任何区别。嗯？不是，他是是这样嘛你看这个，我我们现在需要一个需需要处理的，你看那个那个第二B那个接口吗？你看第第二B他那个这个repository，他就说他在处理的时候，实际上说我。我是处理这个这个就是说他的集成对象那个那个这种聚合对象处理的都都在这儿去做的嘛。然后他这个就是是呃SanjelData，是是这个调SanjelData service，他他只他有这一个，是他他把这个把这个变把这个呃SanjelData service调用转成异步嘛，对吧？

00:29:42 
嗯，然后他他的他又去加他这里头我看到他他他有两个东西嘛，一个是，他他有这个一些一些那个validation啊，可能后后面是不是还有一些，啊做一些，validation service啊什么的就就就这这些事情你要要你们要把这个事情看看明白。实际上他就是在在在之前做一个数据准备嘛，如果是个聚合对象，他他要把聚合对象去拆解然后。去去那个是这聚合对象怎么更新呢？什么的都是在repository里面去做，它就是一个它就是一个adapter嘛，它就是一个adapter，去去连那个SanjelData嘛。因为你看它在这个底，这个不是delete.

00:30:39 
他在update我看到这个就是他一个update嘛。update这个对象的时候，那么他他的子对象，就是这个这个只有order嘛，这个只有order他他update然后他他再再，再再往下传去update这个的时候。这order是这他下面还有这个，啊。啊叫job order。他的一一层层去来给你处理嘛。嗯嗯。嗯。我我我的意思是。他不用嗯，细到每个都有一个子分类，他就。他可以有一个，看情况吧，可以那个什么。不是我我我们现在讨讨论另另外一个一个思路呢就是说。

00:31:35 
我们后面这这这个东西，我们原则定下来，我们都我们不用去写啊，就跟女元芳一样，我不用去写，我生成就完了。我们只要把把这个模模式定下来，这这这种就是我聚合怎么处理，这代码都是一样的嘛。然后我我我的数据的那个什么那个合法性怎怎怎么检查，我怎么去定义。其实加上一些约束什么的都都都是一样的嘛。然后这个他这个这个整整个的映映射怎么映射。就是。我们要定我们在讨论什么我们他在讨论我们定把这个模式定下来嘛。嗯嗯。

00:32:32 
定下来的这就是这些那以后要教会宝宝贝他们去那个张燕就你就按这个模式去写一步一步去写你不会用那啥是那个如果我们和是那个秋风这边他他这工作主要是我们后后面怎么用AI或者我们建建AG它我们再去让让让自自自己去把它那个就自己写出来。嗯，其实词模板也好或什么也好我们就就让他他自己说。啊，我们加了这么一个那啥，我们就就是用用到哪些实体，我这直接就把这什么加出来了，直接把这个就是这个repository那个repository这这层也也直接加出来了。那么我们repository现在就是呃两个职能嘛，现在我们现在现在只有一个职能，就是做这个和那个。作为。

00:33:31 
这个数据访那个数据访问层嘛，就是作作为本身的那个你这层的数据访问层嘛。然后就是说这样我们可以把这个，这个三调data service插进来嘛。嗯。

00:34:02 
那么的，那么以以后那现现在是先先现在这这个我们现在没先没有就是说那个呃我们如果是调用那个呃Sanjellibrary的那个process的时候也不管是三Sanjel还是process了调调用任何333角Sanjellibrary的的那个服务的时候也也需要通过这个repository。

00:34:32 
接进来嘛。嗯。就是他repository是所有的外面包括我们后面的集成都都是通过repository集接进来包括你写的那什么你写的那个呃。包括你写的那个e service集成那个也应该是在repository里走嘛。我不知道你现在现在写到哪儿了那个。靠靠，写的命令。对啊。你就应该是在在这也就是你你repository是是一个就相当于一个聚合器，它把所有的呃对外界服务都聚合进来嘛。这样基本上就就就比较清楚了吧。秋风。

00:35:31 
呃有有问题吗这个咱咱咱这么说。哪个？哪个哪哪个地方？哦，de，business，process是这样，就是说那个这个。老洪呢在这里面写了一个business process business process呢它是完全这个就是完全是逻辑，它是我所有的在这个business process里面都是提出来的静态方法。嗯，我知道。啊，那么这这个这静态方法呢就是说等于说我们在做这个。在做这个呃。在service里面呢service里面service是为那什么提供服务。

00:36:28 
为那个呃为呃UI层提供服务啊去去响应UIUI层的请求。但是呢呃这这个这个请求你就有这个逻辑请求有数据请求就有有不同的请求嘛对吧，那么数据请求呢就会转发给这个repository。嗯呃那逻辑请求呢这这样就把分出来b ean process逻辑请求会去那个呃。就是去啊调用这个process逻辑请求，我怎么定义这个哦逻辑请求。其实其实最最最典型的一个是是这个我给你看，这是这个呃最最典型的业。你像呃我们逻辑请请求里头呢有，比如有有计算，或者说我们这个有这个呃我们这这这个是最最典型的一个我们就是。

00:37:25 
呃，构建这个构建这个它的那个就是注注释就是有格式化的注释。那么这个呢就是说其实我们是构建一个格式化的，那这个东西我们在做的时候呢，实际上你构建的这个这些东西是对还是不对？那么我们一般就是我们会会要需要给它写个测试，来保证它这个东东西是是是构建是正确的。写写应该写写应该写一组测试。那么这个东西呢，我要我必须要能拿出来，我单独去测。所以呢，我把把它把这个拿出来呢，那么它这个地方它会就会有个这个有个有测测试项目专专门对专门对对它进行单元测试，就是这样，我就是说把逻辑抽出来了嘛。这样就胜在指的公共逻辑还是单个的就是某一个功能用的逻辑。也可能也可能是那也可能是单单个某个功能用的逻辑啊。

00:38:26 
就是就是你刚，刚才你你刚才你那个概念嘛，刚刚你刚才提出来那个理念嘛，就说你你不想这这一个文件里头写写几千行代码嘛。你要把它剥离嘛，就是这个你在这个service里面呢，它是是做它只是做响响应和拆解。然后它响应拆解，然后说。那先先拆解说你是数据请求我我我去report就是去跟你要数据你是功能请求啊我我去给我我到那个这边那个呃功能服务里去这个process里面去去去给给把这个发过去让他处理处理完再再返给我就是但就是变变成了协作关系嘛所以呢这样是是这样就是当我遇到一个问题的时候我如何去或者说开发人员。

00:39:22 
如何去界定这个应该是business process呢还是在service里边我就写完了。你是是这样在实，在实实操的过程中呢，说你可以在service里面写。这这没有问题，你可以在service里面写，但是你第一呢你在service里面写的你是不能都不能单独测试的。因为我们要当要要要去做一我们不就是不不给我们肯就是说。我们service呢就说我们我刚才讲就说我们每一层的职责是不一样的。我每一层那么我们就就我们service如果说我们service这个呃如果我们是service呃做做测试呢我实际上就测试它这个去去去调对这个整个的那个呃分分分解啊响应啊就就就是是对还是错的对吧。但是我我都我不不能做功能测试。

00:40:21 
但是那个什么是做功能测试这个你比如这个呃process都全全是全部都是这个呃全部都是逻辑嘛。所以所以你在写实操的时候你可能在这是在service里写一个方法。我大概明白你意思了，但是刚才宝红说就是这里边process business process里边其实少不了对数据的操作，那这样的话它也就是也就有也是有状态的。他不是那种无状态的，我随便测试。呃，所以我我刚开始是这样。不是，是这样，是这样，因为因为我们分层呢，就是说为什么要分一个repository这层？为什么要分层呢？我们分层就是每一层我都可以去把它呃做做做一个mock。做个mock呢，我就可以测试了。我我就说。

00:41:17 
我我分出这个方法有一个什么好处呢就是说我在做这个页面的时候对吧，你比如说我我在做页面你可以是你可以先去做计划嘛你说我这页面有什么东西我就有什么功能我要我要什么东西但是你你不需要全实现呢。你比如说我我们我们build那个那个comments那个格式化的信息对吧。我只是说那个地方我我我只是。在在开发的时候，我只是先先说我我把这接口定义出来，在service里面，在process里定义出那个接口，然后我我我逻辑什么都没有，我就返回一个这个啥这个这个一一个说说test comments对吧？然后你就可以继续向下做。嗯，然后你把这个这大框大架搭起来，你可以然后去一去一点点去完善细节。然后你如果是那个comments是那个这个客户说要求。

00:42:11 
我这个这个格式要变，你要变的时候呢，你不会去动你的service code代码，你也不会动你bless的代码，你就去就动动你process代码去，而且你那个地方是有测试的，你直接去改那测试，只要去改那一个一个单元就可以了。这样我们就把这个就这就是我们那个隔离就是分离的原则嘛。嗯这个好处我明白，我是我我其实就是想说就是。就是在做的实际做的过程中，我们的开发人员能不能就是把这个给他。不是你你不要你你不用担心那个问题。那个问题是啥呢就是你再好架构，那所有人都会打破它。任何一个人都都会去打破这个架构。但是呢我们讲的啥我们是说我们给你这个就是给你一个架构让让你去去去遵守，那么。

00:43:10 
我们就是让你做的事情呢，就是把这些模式都都定义下来。然后后面呢，我们就说是用AI就是去让让让AI去做这个code review。你有他是他是直接把这个逻辑写在service里没有问题，这个是是工作的。这是工作的，但是我这真的我们可以让那个AI去review时候说你这个地方是不不符合那个这个架构设计原则。甚至A我们其实际这种情况下在这种情况下实施我们直直接可以让AI做做重构的AI直接能给你提出去。所以所以你这这这个你你你不用担心因为你再好的架构定义好了这这个人是都都都会给你给你作乱套的。但是我们就说我们有一个架构原则呢我们现在就是说去呃遵循这个大架构原则。

00:44:10 
然后呢，我们这就是教育教育这其他的开发员呢去遵遵循这个原则。那么我我们再一个就是说我们要教教育AI去让AI去遵循这个原则。呃，是AI是AI也是就是你说的这个原则呃，我还不太清楚，就是这个什么原则，就是就是是应该放在这个。你你现在现在我们就讲说。我们现在这个架构。它的架架架构层次关系是是这是怎么设定的，对吧？它各个各架构中的各，各个组件是这是怎么相互协相相互协作的？每一个每一个组件它的它的职责是是做什么？然后你给给给它一些例子去就像从我们这个在代码里就截出一些例子就是说我我我这这两个它俩就它俩的协作是什么样的？它你你给给给了几个片段对吧？

00:45:07 
给几给给的给几个片段，他俩是这这么些些些相互调用的。他的职责是是干什么？那么这这个你就作为最后作作为提示词给那个AIAAI的。然后你告诉这你你你告诉我现在要实现一个页面。然后你知道让AI去按照我我这个这个啊呃架架架构的那个说明去把这个这就是该给你建出来的这这这些这些各层的文件。对，就是说一次性就去给你建出来，他就按照你你这个规则就是我们对我们这这这个呃职责定义的这个每一层的职责和他们之间关系就就就是这样的嘛，他就是遵遵呃AI就理解了他就他就按照我我们这个规矩去去去建嘛，其实这人人也是一样的你你告告诉这个呃张张院和那个保卫你这这个东西呢你。

00:46:05 
数据读取你就就就必须要这么一层层的去走。其实其实你看张院他们写代码也也没有差那么远，他们他们自己写的代码也没有差那么远，你你写代码也也没有也没有差那么远嘛。现在我们就是说不统一那张院，那些很多东西都都都写到那什么里头，都写到那个reader里面了。而我我们说说我们希望这个所所有人写写出来这个这个模式是一样的。每每层这个干什么的代码是都都都在它应该在的层。你否否则的话你就你比如说你这逻辑代码到到处都是，你让AI去去做代码去code review你你都没法做，你要让AI做code review，你必须要给它标准呢。

00:47:05 
嗯。现在呢你你要做的事情呢就是呃把这个刚才我我们说的这个整个描述的架构有多少层每层之间是相互是什么关系，然后他们之间是怎么调用的然后他的代码的那个呃示示例。把这个把这个文文档要做出来。

00:47:36 
我我我可能还是没有说清楚啊，其实我不知道就business process，我我现在我感觉对这个划分它的那个啥不是很清楚啊，什么到底什么东西应该放到business business process里边儿。这个例子我你你说的我也大概明白，但是你要让我比如说有一个新的让我去呃呃就是说。界定它在应该是在service里边还是应该在business process里边，我感觉这个界定的条件我还不是特别明确。我不是跟你讲了吗？就是说你你在这个就是你这个你没有business process，你写在service里头也没有问题。这这个东西是是不是就是说这个东西是个经验性的东西，是一个是一个。

00:48:35 
呃。是一个什么是个共共共识性的这个啊决定，就说你什么是business process，就是说你你你简单讲就是说这个东西呢是一个啊静态的方法。就是你可能可以抽出一句，就是你你在写代码的时候，你即使都写在那service里面，你也会自己把它分成一个一个小的方法。当你把那个那你那一个个小的方法实际上它就是不就就就是能抽出来的这个逻辑。你什么原则去去去那什么去这个什么去去抽这些方法啊？

00:49:34 
Model转成view呃那个我也在service里边做了，但显然我感觉是不适合放到business process里边的。不是business process是它我们说business process呢是business process，它针对是business实体。嗯，所以它在在在这这这里面，它对实体它只依赖于model。嗯，哦，这是一个条件。他他只他只是对model这这个他这只做实实体之间的那个呃操作，他根据实体之间的关关关系状态，然后去去做实实体的操作。你比如他他有些是一些你比如说一些条件，在什么条件下，他应该变成什么状态，什么条件变成什么状态。那这这这个东西可以就是process。

00:50:29 
我满足了什么条件，它应该是是是变成一个什么状态，然后我我更新数据库。这这这个就是这这就是一个典型的process。这样说我就清楚了。啊，因为因为这个我跟刚才跟你讲的你可能都不清楚，就是在这个地方的process是完全是基于model的，就是针对于其实其实我们还刚才还还提到我们还有另外一个。另外一个地方放process就是在central library怎么放的process。central library怎么放就是在跨应用的那个这个呃他们共共这个共共享的process，那么我们会会把它放到central library里面。那么central library呢，那么它这个process是通过就我们刚才不讲嘛，通过这个repository对吧？它属于第三方服务嘛，类似就是相当于第三方服务通过repository然后。

00:51:26 
提提供给service去用。那么我们在现在做的时候呢，所有现在做的service呢，this process是做在这个呃呃这个项目里面对吧？然后我在在service里可以调这个process。那么等到我们做完了以后，我们要做其他应用，发现其中有有的有一部分process呢，我是可以啊，我就可以推过推到library的时候，那么我我们就把它提出来，然后把那个再再再变成第三方服务。直接调用他们的接接口都是一样的。也就是说，business呃business process其实也就是对呃一个或者多个model它呃它需要产生的一些副作用进行一些处理。对，就是他们他们这之间的一些相互作用那个就进行进行处理嘛。

00:52:25 
你这样说我就比较清楚了。对啊，因为因为你看这这种这种是典典型代码嘛，就是你你有很多条件，其实各各种不同状态，然后决定它是什么状态，这种是这这种是典典型的逻辑嘛。嗯，就类似于就是比如说我一个用户被删除的时候，用户相关的东西我也要做相应的处理。呃，那个还不是那个呃那个对那个你是那个还不还不一样。啊。那个那个是实际上是在那个那个是在repository里repository里面去做的那是那是就是说说完全是数据操作，那不是逻辑，那是数据操作。就是说你你要删一个用户，然后这时候用户呢他关联的是那个数据，对不对？然后你你做关联数据操作，那那个那个是那个那个东西是它是数据关系，那数据关系应该就是那个。

00:53:24 
是应该是在那个reposit里面去去去做我们现在先讲的是这个业务关系它这个数数据就是那个它数据属性之间的那个这个啊逻辑关系。嗯。刚才就给你讲如果是那什么呢如果是这个呃。如果是你要是说数据数据操作，就像刚才给你讲这个例子。第二，B里头的这个这个例子，就是说我们在做这个就保存一个啊哪儿去了？他他在他不是这个，他他在他在保存一个这个sales project的时候，对吧？他他相关的他他他要插入这个。

00:54:23 
这对他这个里面的子对象，这个叫job order进行处理。job order进行处理以后呢，他还要还要对他的子对象叫job order进行处理。然后你要删呢删删掉一个project呢也是要要这么一层一层的，这这是他在那个这是他的数据处理的层这个这个聚合关系啊啊。或或者是这个呃。这这这聚合关系的处理。但是你要是说你刚才讲的那种情况，如果是我要删掉一个用户对吧？那么我我把他的那个permission也要删掉，从permission里去删掉一条数据。你刚才讲是那个意思对吧？类类似那个就是说你啊。嗯我我在我看来这呃有点儿有点儿像就是我我也。

00:55:21 
用户的这个model属性变了，他受影响的其他的我可能需要处理吧。哦，对，那你你可以在process里面处理啊。这个这个就是说你现在我们讲的是只要把这个架构组那个做出来，把架构定定义出来。那么这个就就是每个人在做的时候呢，你这这个东东西你是觉得是不应该放那里合适，觉得不应该放那里合适。你你应该放那里你没放，这一般是没问没问题的。但你不应该放放那里你放了可能会有问题。

00:56:17 
是，你，所所以呢就是说这这个我们一般都是就是说你不会一一上来就做顶层设计，然后就是说啊我要建基类，我要继承，我要做这这我要抽抽出方法什么，你这个你你一开始做的时候呢就是说你清楚的东西你会拿拿出去，就是说你会做一个方法，然后我说非常清楚我这个东西就是一个静态的东西，我出去单单独处理，我可我可以单独处理。但是你要你有一些东西绑就是搅在一起的时候，搞不清楚的时候，那那一开始就就就可能就搅着就搅在一起去去在service里面去做做完了呢，就就是做完了脑子更清晰了，再再重构，再把它剥再再把它剥离。嗯嗯，所以所以这个我这个不是不是一个非常清晰啊，这个东西就应该是process，这个东西就应该是service。我们有原则，但是并并不等于说这这个东西就是要要把它一刀切。

00:57:16 
而且现在要求你们做做的事情呢，也是不并不是把这个东西也一次性做好，而是我们只针对现在这个这这个任务，现在我们就谈宝红要你要你要做你要做那啥，你要去现在宝红这边一个人做这个项目，我们就啊这礼拜做完了。那么现在宝红他他逻辑熟，他做他做前面这一块。现在张院在做界面嘛张院做界面，然后那个宝宝红就做service和process这这这一块。那么后面的那个model呃repository和呃这这这个就你来做。行。然后你需要跟宝宝红把那个这个model再再再过一下，看有有没有问题。因为model我们讲一个原则，这个model和这个。

00:58:13 
呃和呃这个我们三张data的那个那个entity他们是同构的。他们是结构这所有的东西是一模一样的，只不过是就等于是做了一个copy。做了copy在在在这个就是在这个项目里面，这这个他们这个当时做第二笔设设计的时候就是为了跟三跟那个三张。去分开，他在没在这个我们是那个人员房里面，这个这个模型没有更新的前提的时候，没有更新的时候，他们可以去更新model，然后就是可可以做这个就是做前台的功能。用mock数据去做前台的功能，那么这样就是他他会呃然后他回回过头来说我要加哪些属性。

00:59:11 
因为他们不是那个，不是他们不是这个model追问的。嗯，啊，这样的好处呢，为什么我会留留着这个这这这个这个模式？这样好处呢就是我们我们可以可以呃减减轻对那个三SanjelData依赖。因为我们做一次real line的时候，我们是直接依赖三这个SanjelData这个model的的under day。那么我们我们做做就是改任何东西的时候，我们。都要说哦，我要先去改别人方。我们是是模型驱动，但是但是我们要要先改别人方，我才能接着做。不改别人方，我就做不了。嗯，我明白。啊啊，所所以我我就保保嗯保存了他这他他这个架构，所以就就就多了几个这么一个model。那。

01:00:05 
知道了啊，那你就是那个这个任任务明明明确你就大概去啊去看看一下这个和呃刚刚才我们讲的是呃service是以那个页啊页面那个啥是吧我们是以是以页面为标准是吧一个页面一个service。然后就等等等一下我把那个这这边咱们的这个我AI生成总总总结发给你呃看大大概可能就是你他整理完了你可能更清楚一些。宝红有有有没有什么问题？嗯，那个有点问题啊。有点问题，就刚才说的那个。

01:01:03 
Business process和那个recovery，process的。啊。嗯，刚才说，service直接可以叫business，process。是吧？Service直接叫business，process。嗯。对。嗯，那我在想我之前这么做的原因是什么呢？我想一想。我之前这么做就是。嗯，有一个原因就是。这个process将来有可能是挪到。然后这个时候它挪过去的时候，它它一个是model一个是时序，它不能直接。不能直接那么换嘛，就得同时process那块再换一下。不是你，你现在的那个process它的它就是只依只依赖于model吗我们我们现在定义的这个process。

01:02:02 
嗯是，是就是是的。他直接调用是没有问题，就是将来换的时候，他不能他他得改service的，现在现在，现在你如果说如果说是把，我把那个process挪到standard library里边以后，我只我只改，那个report他们就行了，我service其实是不用动的。你现在直接用service去调process的话那到，我以后还要改那个什么吗。要改。还要改那个service。那你，那你说是，啊你的意思说那我我们这个，啊process是通过repository去去调。嗯，现在是的是的。

01:03:01 
呃也可以。他相当于其实就是个接口，然后转了一下。是是，呃也可以，那就是那那就是那个process，因为因为这样就说呃相相对是合理，因为他俩是是一个接口嘛。就是那个呃呃library，Sanjellibrary里面的process和那什么和那个就是本地process，它就是等于说是同一个接口嘛。然后你这个就是等于是他俩就是说你你你把哪个插入到那个什么插入到repository里面去对吧？嗯，但那那就是说你现在repository里面就就要有有这个呃process这个方法的接口。然后这个service去去调呃service如果需要调process的话是从这个呃repository里面去调对吧？嗯嗯。

01:03:57 
那你这个那你这个repository叫什么叫是叫专门建一个service repository啊，还是business business process repository？没有，他直接就在，直接就相应的相应的那个嗯那个啥。我刚才看了一下，相应的那个比如说bin process直接在那里边调。我觉得啊。

01:04:33 
跟谁逻辑相近的就我我觉得那那你要是要做这么的你是不是就是其实呃因为我们其他都是实体嘛。嗯，他就打破了那个，就破坏了他那个原则。不是你其他都是实体嘛。嗯。啊因为我我们在这个里里面我们我们有一些功这个属于那个呃。这个功能性的那个repository嘛你比如说我们这里面有这个。呃，dependent呃，data repository，对吧？他这这这怎么又建一个master data repository呢？他他俩不是一回事吗？忘记了哟，这个是为了那个计算嘛，他计算那个他的那个嗯model那个信息信息不全，然后然后那个什么他那个mapping也写的也不全。

01:05:31 
写写写的不全你改mapping嘛。写的不全你改mapping嘛或者你你再再增加一个mapping方法嘛。因为你你现在就是说你你你这这个。呃，dependent呃data model这个呃repository，其实它这东西它它是要那个怎它是它要就要那个呃载那个加加载到那个内内存的。嗯。它它是要要cache的，你master的data这个它它也要cache的，所以你就多多占内存了嘛。嗯。

01:06:26 
Because I'm talking about this， it has this functional kind of repository. So so so you this， then if it's like this， you may just you put all the bin process just all. You because you if in this in this entity repository add these methods， these methods that it doesn't have that.加这些方法，这些它它是因为你是调了process嘛，它它又没有那个呃，就是不是不是是是实体的这个它的方法嘛。嗯嗯，对。所以你你你要如果这么做，你要从这边这repository走的话，那你是不是就就建一个business process repository啊？嗯。这是不是直接跟在service？

01:07:21 
不是他不他他他对谁那个他他他做的是是他那个宝红提的问题是这样就是说啊因为我们想这个两个service呢不就是说它的接口应该是它它是插入的嘛它应该在同一个地同一个点上插入。这样你才能替换嘛它相当于一个一个USB嘛你插的是那个library。或者你插的是本是是是本是是本地的那个啊process这这这个都是要插入是在同一个点插入啊你可以然后这样你才能替换呢。那么我们先之前讲的说service直接调process那那么这个这个就说将将来会有什么问题呢就是说我们如果说把一个是一个这个process挪到library里的时候时候我们还还是需要是从那个repository走一下嘛。

01:08:23 
所以这个东西，因为它俩是它俩是插入的，它俩是一个东西啊，一个是只不过一个是第三方的，一个是是就相当于相相当于插件嘛，你可以替换的。我知道我宝峰你自己想一下，我觉得这个你实际操作的话，无非就是换换命名空间嘛，统一替换一下就就完事了吧。啊，不是不是，不是你。你从从从架从架构上还是先讲，就是就就是说你其实那个我一开始想的呢，就是说你这个东西我我就是提货，我我也可以替换嘛，到时候我替换。我第三方的，我从通我通过那个了那个repository来接入嘛，那我就如果本地的我就不需要接入嘛。但是宝红提出来这个问题以后呢，我觉得那他俩你当你把他俩看作是同一个东西的时候。

01:09:22 
他俩有同样的接口的时候，你就你你进行替换，实际上他俩的那个接入点应该是在一在一起。所以我宝红这个啊这个想法，我我觉得也可以啊。所所以呢，这样就是说现在我就说那么既然是是如果是我们就因为repository它就是一个它就是一个那个一个这个聚合器嘛，一个适配器嘛。那么在这时候呢，我我我就说。那么，关于我们的repository命名，那么我们repository基本上都是就我们是第一个原则呢是以实以这个呃以实体命名嘛，就是每个实体会自有个自己的repository嘛，对吧？那么我们同时也有一些功能性的repository，那么就是像这个啊permission啊或或者是这个呃master data啊啊什么的。那么我我就说，那么我们这个。

01:10:19 
呃，bind process实际上我们就可以是不是可以分出一个自己的一个单独的repository就叫bind process repository。他他并他不通过那什么走他，就说他并。就是，让实体的repository更干净嘛就就就只他只是做做是做这个啊。调用啊，三调data service的。适配器对吧？它只是做数据操作。那么有一天我我我们想想换了，我们想换换成那啥，我们那个呃后这个底层换成Java了，我我那我数据操作那块我就我就只只是那个做那什么嘛。我数据操就是我后台比如我换了换换换成那个Entity Framework了，那么我后面数据操作我只需要处理这些Entity的那个Repository。

01:11:17 
这个business process repository不需要处理吗？嗯。那是准备就是新新新加一个这种类呢，还是就是只是把这个呃呃repository分多个类文件呢？我没明白你这个新加一个类和那个多多个类文件是有啥不一样？就是拆成两个文件嘛。就还是命名都保持一致，然后前面调用还都通过呃同样注入的这个repository直直接调，还是说单独加一个新的类，比如说bin information呃business process repository。不是我的意思就就是就是一个repository，就叫business process repository。啊，总的一个是吧？对，就一个总的对啊。嗯。

01:12:17 
那么在在这个里面呢，它是它啊啊，总总的如果多了之后会不会乱？不是，是这样呃嗯呃多了再说，我我们就是多了以后，我我我们再那个再再再根据多的情是什么情况，我我们再去重构嘛，再去分嘛。嗯。是啊，因为现在如果上分了。就分上来我我们就是啊的这个啊每一个跟实体每个都process report，那那个是啊就是说就是太太零碎嘛，每个里有的里头有方法，有的里头没几个方法，有的没有方法，对吧？然后你你这造造出一大堆一大堆空代码。但是呢我们我们就是说这个后面的就这个这个bin process呢应该是按着bin process去走。

01:13:16 
就是说，如果后面里面分包的话，我们是肯定是按business process去走。你比如说，你比如说我们说我们分呃一个可能的方向呢，就是business process，我们可能是按部门去分。后后勤这个business process这个这这是后后勤管的对吧？运营process是运营管的。我们可能分分包可能是这么分。就是说他的逻辑是是是跟跟跟运和运营里面是是是相关的，他那边是和和这个后勤相关的对吧？嗯，可能是按部门去走啊。但现现在我们还没没有没有那么清晰啊，但我们知道就其实我们大概这也也知道我们比如说我们如果大大方向分呢，我们可能是说job process。

01:14:13 
然后，prada hold process。这些大的大的我们知道可能就是你你就是在就是大大的那个分块我我我们是知道的，但但是现现在现在没有那么多也也没有也没有去必要去分，因为在那个什么里头，在这个，在三加library里面，这个process是是开开始分包的啊。

01:14:54 
行行，我没问。那谁那个宝红这样行吧？对，加a business repository，然后在那个把你就把那接口直接拷到那个呃那个i business repository里面，然后把那个。就就直接过一下就完了嘛，对吧？对啊。这个你这个你可以让让那个陶玉峰去去去重构。就是。啊？什么？你说I，business，repository啊？

01:15:52 
我我现现在这个里面建的这，就是建了这么多的那个。这么多的文件夹。那个the business pro那个report肯定是放到根下。然后以后如果我们重构的话，可能我们就如果是说分分成几个开始拆分的时候，我们可能把它把它变成那什么变成这个啊变成这个什么变成这个啊一个一个文件夹，然后里头有里头有有有几个啊。因为我现在看看到这。

01:16:49 
这这个里面呃。那你这个这个attention是。不是你attention是原来就是第二B里没有是吧那你你新做的是吧啊。哦，他有的common是吧，不是common。不是，他是repository，不是这个，他是。repository。哦，他有这个。哦，他这里有也有，OK，好的嗯。那那没没没有问题啊。

01:17:47 
因为他因因为他原来这个他的他的这个文件夹里面是做了一些，就我我不知道为什么当时没拷过来啊，他这个开开开始拷过来了哈，公共的全拷过来了，拷过来了，公共都拷了是吧？嗯，全拷过来，结构也一模一样，那个extension用不用挪到common里边？呃，先现在先不要管他这些事情，你就把那个process先先放到跟下吧，好吧，我们我们慢调，我们我们这这这次的主主要目标不是重构，我们今天就把这个把这架构再再再明确下来。然后那个谁那个秋风把这个这个文文档写出来，然后呃那就就是你你俩再就是就具体再沟通那个那个谁那个秋风就。

01:18:45 
就是把把这个repository。就是说那个宝红包的就是说说哪些repository是在我们做做这个product haul这个这个schedule product haul就是hubland的在这地方我们要用到的。我要用到的对吧相关的那把把这个这这这部分按照我们的架架构去给他给他安排就位给他就都都做代码调整安排就位。

01:19:16 
然后他他那个那宝红，你就你你的你就是你你的重点就是在前面，在service和那个和和前端嘛，对吧？那你你跟着你跟秋风去去沟通好，那个就是那个你repository那那那边需要需要调什么嘛？这这个这接口定义啥的。结结果定义定定义好了你你就坐前面他坐后面嘛。你不要不放心别人做。你不要不要不不放心别人做你要放心放心那啥那个。

01:20:12 
就别别别人去做那啥就就就是你把定接口定义好就行了。你说你你在你你把那哪哪个repository里里边有哪个接口，然后你的process如果是在那什么就刚刚刚才跟秋风说的那个讨论的时间就是你在这个一些逻辑就在没在那个就没准备好的情况下你是可你可以在写到service里写成这写成。一个单独的那个私私有方法嘛，对吧？嗯，然后你重构的时候再就就就把它往后移移，把那个呃接接口一加就可以了嘛，对吧？嗯，然后你你俩大大大概按这这按着分工去把这个。

01:21:08 
啊，工作量估一下，那个加加个ticket的工作量估一下，我们大概我们那个宝红，你看你把这个这部分呃分给那个呃秋风以后，你那边能减掉多少多少时间？能不能减掉一半？减不掉。因为我在预估的时候其实是他的那部分，我其实就。就没估是吧？就。就不算时间是吧？嗯。嗯。那就是那谁那个，秋风去给不是跟去给你重重重构嘛就把那个，把那个。

01:22:03 
Business process移就是移到这个business repository下面了，对吧？嗯，然后现在是是两边两边并存嘛，然后你你那边再再然后再把你那个你那边对business process调用再存再service里的调用再重重构一下嘛，就是说那个然后把原原来business process给它删掉嘛。嗯嗯。不是不是删掉，把它引引用那个改到那个repository嘛，对吧？嗯。

01:22:40 
那就那啥吧，那就这这这就就这么做吧。那个谁那个呃秋风就负责这个这这整这个架构的文档。然后那个，呃把那个process那个。呃，repository建起来，把那个接接口都定义都定义好，然后把这个实实体需要的实体的那个呃实体的repository。都建好最主要的就是那个product haul product haul repository它下面就是它因为它它下面是，你看它那个实体是product haul下面有shipping load sheet和呃呃blend unload sheet就是第二层有这两个然后呢shipping load sheet再往下还有一个pallet load然后跟它相关的呢还有。

01:23:39 
这个呃rig job呃还有rig jobSanjelcrew assignment。然后Sanjel然后再相关的呢还有啊Sanjelcrew。还有Sanjelcrew啊。schedule，Sanjelcrew schedule又又聚合下面呢是啊呃work schedule和unit schedule。这个这个在那个在那个什么上在我们的那个文档上。这个这个图是有的。等我给你找一下啊。我不知道你你秋风你可能以前看过，你可能看过这个图。嗯，我可能也哎呦不对，我可能给移到那哪儿去了，移到MBM里面去了。

01:24:39 
诶。

01:25:18 
就是就是这个这个model。所以你在这这个repository可能是比较复杂一点。就是这product Haul product Haul下面它有有product Haul有pod load，然后有shaping这个有shaping load系列的shaping load系列的下下面，有这个你看这都都是小小的那个呃黑那个黑方片嘛。然后这个是它下面有有有这个。然后呢，他这这这边他相相关联的还还要处理这个就是这个schedule这这这边这是有这个rig job。有rig job，然后这个有这个，啊还有这个schedule，这schedule实际上这这个图不对，这这图schedule是直接直直直接关联的这这个，呃是schedule直接关联到这个section了，这。

01:26:17 
然后它它下面这这下面又有又有这个这两个schedule。所以然后那个你如果是第三方是这一部分。嗯，这些好像都没有了。啊。

01:26:47 
所以所以这个是是schedule这这这个就是在在repository里面呃就是处理。或者说或者放到那什么里面处理放到那个process里面去处理。啊。我跟你说听不太清楚啊。

01:27:18 
嗯，schedule这个，它那个report上面一个都没有。这个要要加吗？对啊，那那那你要加呀。嗯，那这个。这不这个秋风去加嘛我我我不给他讲这个什么嘛讲讲这个，这个model嘛。就是这个，呃，Sanjelcrew schedule里头，它还就还还有一个，指向那个什么的呃。

01:27:54 
指向那个三焦cru section这个。这个地方是专门讲schedule的。那谁那个。这这个这这个地方是侧侧侧更侧重那个schedule的那谁那个那个。就放。然后代代码里头你你也能找找到那个他在那个在eservice online里这部分逻辑也能也能找到你先。这样你在那什么里头处理再先你可以先写到repository里面，去去处理，好吧。

01:28:46 
然后这个是prada haul，这个实际上是更更更强调是这个prada haul这边他们之间的关联啊。这这个这个是这个prada haul，这个是是三层聚合。不是不是这个，是这个。它是个3层聚合啊。

01:29:21 
行，那这那这样就说那个那个谁那个呃那谁事儿更多了这个秋红自自己那啥自己去创建个任务吧，然后自己把那个里里面一些这应该做的事情列列一列，然后明确一下，然后就干嘛，然后明明明天晚上咱们再再。再review一下好吧。行了，宝红。好。啊，那行，那就这样。嗯，好的。好嘞，嗯，好，拜拜啊。拜拜。
